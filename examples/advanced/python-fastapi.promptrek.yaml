# yaml-language-server: $schema=https://promptrek.ai/schema/v3.0.json
schema_version: 3.0.0
metadata:
  title: Python FastAPI Application
  description: Production-ready FastAPI development with async patterns and best practices
  version: 1.0.0
  author: PrompTrek
  tags:
    - python
    - fastapi
    - async
    - api
    - backend

content: |
  # FastAPI Development Guide

  ## Project Architecture

  **Tech Stack:**
  - Python 3.11+
  - FastAPI for API framework
  - SQLAlchemy 2.0 with async support
  - Alembic for migrations
  - Pydantic v2 for validation
  - PostgreSQL database
  - Redis for caching
  - Pytest for testing

  **Project Structure:**
  ```
  app/
    api/
      v1/            # API version 1 routes
        endpoints/   # Route handlers
        deps.py      # Dependencies
      router.py      # Main router
    core/
      config.py      # Settings
      security.py    # Auth logic
      db.py          # Database session
    models/          # SQLAlchemy models
    schemas/         # Pydantic schemas
    services/        # Business logic
    crud/            # Database operations
  tests/             # Test suite
  alembic/           # Migration files
  ```

  ## FastAPI Best Practices

  ### Router Organization
  ```python
  # app/api/v1/endpoints/users.py
  from fastapi import APIRouter, Depends, HTTPException, status
  from sqlalchemy.ext.asyncio import AsyncSession

  from app.api.v1.deps import get_current_user, get_db
  from app.schemas.user import UserCreate, UserResponse, UserUpdate
  from app.services.user import UserService

  router = APIRouter(prefix="/users", tags=["users"])

  @router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
  async def create_user(
      user_in: UserCreate,
      db: AsyncSession = Depends(get_db),
  ) -> UserResponse:
      """Create a new user."""
      service = UserService(db)
      user = await service.create_user(user_in)
      return UserResponse.model_validate(user)

  @router.get("/me", response_model=UserResponse)
  async def get_current_user_info(
      current_user = Depends(get_current_user),
  ) -> UserResponse:
      """Get current authenticated user."""
      return UserResponse.model_validate(current_user)
  ```

  ### Pydantic Schemas
  ```python
  # app/schemas/user.py
  from pydantic import BaseModel, EmailStr, Field, ConfigDict
  from datetime import datetime

  class UserBase(BaseModel):
      email: EmailStr
      name: str = Field(..., min_length=2, max_length=100)
      is_active: bool = True

  class UserCreate(UserBase):
      password: str = Field(..., min_length=8)

  class UserUpdate(BaseModel):
      name: str | None = Field(None, min_length=2, max_length=100)
      email: EmailStr | None = None

  class UserResponse(UserBase):
      id: int
      created_at: datetime
      updated_at: datetime

      model_config = ConfigDict(from_attributes=True)
  ```

  ### SQLAlchemy Models (Async)
  ```python
  # app/models/user.py
  from sqlalchemy import Boolean, String, DateTime, func
  from sqlalchemy.orm import Mapped, mapped_column, relationship
  from datetime import datetime

  from app.core.db import Base

  class User(Base):
      __tablename__ = "users"

      id: Mapped[int] = mapped_column(primary_key=True, index=True)
      email: Mapped[str] = mapped_column(String, unique=True, index=True)
      name: Mapped[str] = mapped_column(String(100))
      hashed_password: Mapped[str] = mapped_column(String)
      is_active: Mapped[bool] = mapped_column(Boolean, default=True)
      created_at: Mapped[datetime] = mapped_column(
          DateTime(timezone=True), server_default=func.now()
      )
      updated_at: Mapped[datetime] = mapped_column(
          DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
      )

      posts: Mapped[list["Post"]] = relationship(back_populates="author")
  ```

  ### Service Layer Pattern
  ```python
  # app/services/user.py
  from sqlalchemy import select
  from sqlalchemy.ext.asyncio import AsyncSession
  from passlib.context import CryptContext

  from app.models.user import User
  from app.schemas.user import UserCreate

  pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

  class UserService:
      def __init__(self, db: AsyncSession):
          self.db = db

      async def create_user(self, user_in: UserCreate) -> User:
          hashed_password = pwd_context.hash(user_in.password)
          user = User(
              email=user_in.email,
              name=user_in.name,
              hashed_password=hashed_password,
          )
          self.db.add(user)
          await self.db.commit()
          await self.db.refresh(user)
          return user

      async def get_by_email(self, email: str) -> User | None:
          result = await self.db.execute(
              select(User).where(User.email == email)
          )
          return result.scalar_one_or_none()
  ```

  ### Dependencies
  ```python
  # app/api/v1/deps.py
  from typing import AsyncGenerator
  from fastapi import Depends, HTTPException, status
  from fastapi.security import OAuth2PasswordBearer
  from sqlalchemy.ext.asyncio import AsyncSession
  from jose import jwt, JWTError

  from app.core.db import async_session_maker
  from app.core.config import settings
  from app.models.user import User
  from app.services.user import UserService

  oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

  async def get_db() -> AsyncGenerator[AsyncSession, None]:
      async with async_session_maker() as session:
          yield session

  async def get_current_user(
      token: str = Depends(oauth2_scheme),
      db: AsyncSession = Depends(get_db),
  ) -> User:
      try:
          payload = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
          email: str = payload.get("sub")
          if email is None:
              raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
      except JWTError:
          raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)

      service = UserService(db)
      user = await service.get_by_email(email)
      if user is None:
          raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
      return user
  ```

  ## Testing with Pytest

  ```python
  # tests/api/v1/test_users.py
  import pytest
  from httpx import AsyncClient
  from sqlalchemy.ext.asyncio import AsyncSession

  from app.models.user import User

  @pytest.mark.asyncio
  async def test_create_user(client: AsyncClient):
      response = await client.post(
          "/api/v1/users",
          json={
              "email": "test@example.com",
              "name": "Test User",
              "password": "securepass123",
          },
      )
      assert response.status_code == 201
      data = response.json()
      assert data["email"] == "test@example.com"
      assert "id" in data

  @pytest.mark.asyncio
  async def test_get_current_user(
      client: AsyncClient,
      authenticated_headers: dict,
  ):
      response = await client.get(
          "/api/v1/users/me",
          headers=authenticated_headers,
      )
      assert response.status_code == 200
  ```

  ## Async Patterns

  ### Background Tasks
  ```python
  from fastapi import BackgroundTasks

  async def send_email(email: str, message: str):
      # Async email sending logic
      await email_service.send(email, message)

  @router.post("/register")
  async def register(
      user: UserCreate,
      background_tasks: BackgroundTasks,
      db: AsyncSession = Depends(get_db),
  ):
      created_user = await service.create_user(user)
      background_tasks.add_task(send_email, user.email, "Welcome!")
      return created_user
  ```

  ## Performance & Caching

  ### Redis Caching
  ```python
  from redis.asyncio import Redis
  import json

  async def get_cached_user(user_id: int, redis: Redis) -> User | None:
      cached = await redis.get(f"user:{user_id}")
      if cached:
          return User(**json.loads(cached))
      return None

  async def cache_user(user: User, redis: Redis, ttl: int = 300):
      await redis.setex(
          f"user:{user.id}",
          ttl,
          json.dumps(user.dict()),
      )
  ```

  ## Security Best Practices

  - Use password hashing (bcrypt with 12+ rounds)
  - Implement JWT with short expiration times
  - Validate all inputs with Pydantic
  - Use parameterized queries (SQLAlchemy handles this)
  - Implement rate limiting
  - Enable CORS properly
  - Use HTTPS in production

  ## Deployment

  - Use Docker for containerization
  - Run with Gunicorn + Uvicorn workers
  - Configure health check endpoints
  - Set up logging with structlog
  - Monitor with Prometheus metrics
  - Use environment-based configuration

variables:
  DATABASE_URL: postgresql+asyncpg://user:pass@localhost/db
  REDIS_URL: redis://localhost:6379
  SECRET_KEY: your-secret-key-change-in-production
