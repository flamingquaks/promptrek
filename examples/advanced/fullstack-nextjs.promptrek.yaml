# yaml-language-server: $schema=https://promptrek.ai/schema/v3.0.json
schema_version: 3.0.0
metadata:
  title: Full-Stack Next.js Application
  description: Comprehensive AI assistant configuration for Next.js full-stack projects
  version: 1.0.0
  author: PrompTrek
  tags:
    - nextjs
    - react
    - typescript
    - fullstack
    - vercel

content: |
  # Next.js Full-Stack Development Guide

  ## Project Architecture

  **Tech Stack:**
  - Next.js 14+ with App Router
  - TypeScript (strict mode)
  - tRPC for type-safe APIs
  - Prisma ORM with PostgreSQL
  - NextAuth.js for authentication
  - Tailwind CSS + shadcn/ui
  - React Query for state management
  - Zod for validation

  **Project Structure:**
  ```
  app/
    (auth)/          # Auth-protected routes
    (public)/        # Public routes
    api/             # API routes
    _components/     # Shared components
  components/        # Reusable UI components
  server/
    api/             # tRPC routers
    db/              # Prisma client
  lib/               # Shared utilities
  ```

  ## Next.js Best Practices

  ### Server Components by Default
  - Use Server Components for data fetching
  - Use Client Components only when needed (interactivity, hooks)
  - Mark Client Components with `'use client'`
  - Minimize client-side JavaScript bundle

  ### Data Fetching Patterns
  ```tsx
  // app/posts/page.tsx - Server Component
  import { db } from '@/server/db';

  export default async function PostsPage() {
    const posts = await db.post.findMany({
      orderBy: { createdAt: 'desc' },
    });

    return (
      <div>
        {posts.map(post => (
          <PostCard key={post.id} post={post} />
        ))}
      </div>
    );
  }
  ```

  ### tRPC Router Example
  ```typescript
  // server/api/routers/post.ts
  import { z } from 'zod';
  import { createTRPCRouter, protectedProcedure, publicProcedure } from '../trpc';

  export const postRouter = createTRPCRouter({
    list: publicProcedure
      .input(z.object({ limit: z.number().min(1).max(100).default(10) }))
      .query(async ({ ctx, input }) => {
        return ctx.db.post.findMany({
          take: input.limit,
          orderBy: { createdAt: 'desc' },
        });
      }),

    create: protectedProcedure
      .input(z.object({
        title: z.string().min(1).max(200),
        content: z.string().min(1),
      }))
      .mutation(async ({ ctx, input }) => {
        return ctx.db.post.create({
          data: {
            ...input,
            authorId: ctx.session.user.id,
          },
        });
      }),
  });
  ```

  ### Client Component Example
  ```tsx
  // components/PostForm.tsx
  'use client';

  import { useState } from 'react';
  import { api } from '@/lib/api';
  import { toast } from 'sonner';

  export function PostForm() {
    const [title, setTitle] = useState('');
    const [content, setContent] = useState('');

    const createPost = api.post.create.useMutation({
      onSuccess: () => {
        toast.success('Post created!');
        setTitle('');
        setContent('');
      },
    });

    return (
      <form onSubmit={(e) => {
        e.preventDefault();
        createPost.mutate({ title, content });
      }}>
        {/* Form fields */}
      </form>
    );
  }
  ```

  ## Authentication

  ### NextAuth.js Setup
  - Use database sessions for production
  - Implement OAuth providers (Google, GitHub)
  - Add JWT for API authentication
  - Protect routes with middleware

  ### Protected Page Example
  ```tsx
  // app/(auth)/dashboard/page.tsx
  import { getServerAuthSession } from '@/server/auth';
  import { redirect } from 'next/navigation';

  export default async function DashboardPage() {
    const session = await getServerAuthSession();
    if (!session) redirect('/login');

    return <DashboardContent user={session.user} />;
  }
  ```

  ## Database Schema (Prisma)

  ```prisma
  model User {
    id            String    @id @default(cuid())
    name          String?
    email         String    @unique
    emailVerified DateTime?
    image         String?
    accounts      Account[]
    sessions      Session[]
    posts         Post[]
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
  }

  model Post {
    id        String   @id @default(cuid())
    title     String
    content   String
    published Boolean  @default(false)
    authorId  String
    author    User     @relation(fields: [authorId], references: [id])
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([authorId])
  }
  ```

  ## Performance Optimization

  ### Image Optimization
  ```tsx
  import Image from 'next/image';

  <Image
    src="/hero.jpg"
    alt="Hero"
    width={1200}
    height={600}
    priority
    placeholder="blur"
  />
  ```

  ### Caching Strategies
  - Use `revalidate` for ISR (Incremental Static Regeneration)
  - Implement route segment config for cache control
  - Use React Query for client-side caching

  ### Code Splitting
  ```tsx
  import dynamic from 'next/dynamic';

  const HeavyComponent = dynamic(() => import('@/components/HeavyComponent'), {
    loading: () => <Skeleton />,
    ssr: false,
  });
  ```

  ## Testing Strategy

  - **Unit Tests:** Jest + React Testing Library
  - **Integration Tests:** Playwright for E2E
  - **API Tests:** tRPC testing utilities
  - **Type Safety:** TypeScript strict mode + tRPC

  ## Deployment (Vercel)

  - Enable Edge Runtime where possible
  - Use environment variables for secrets
  - Configure build cache for faster deploys
  - Set up preview deployments for PRs
  - Monitor with Vercel Analytics

  ## Security Checklist

  - ✅ Validate all inputs with Zod
  - ✅ Use tRPC protected procedures for authenticated routes
  - ✅ Implement CSRF protection
  - ✅ Sanitize user-generated content
  - ✅ Use environment variables for secrets
  - ✅ Enable Content Security Policy headers

variables:
  DATABASE_URL: postgresql://localhost:5432/nextjs_db
  NEXTAUTH_SECRET: your-secret-key
  NEXTAUTH_URL: http://localhost:3000
