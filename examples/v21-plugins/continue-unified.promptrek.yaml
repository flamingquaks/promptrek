# yaml-language-server: $schema=https://promptrek.ai/schema/v2.1.0.json
schema_version: 2.1.0
metadata:
  title: Continue Modular Config Example
  description: Example showing Continue's modular plugin configuration with individual files
  version: 1.0.0
  author: PrompTrek Team
  tags: [continue, modular-config, mcp, commands, prompts]

content: |
  # Continue Modular Configuration Example

  Continue uses a modular configuration approach with separate files for better organization:
  - **Individual MCP servers** in `.continue/mcpServers/*.yaml` (one file per server)
  - **Individual slash commands** in `.continue/prompts/*.md` (one file per command)
  - **Main configuration** in `.continue/config.yaml` (metadata + prompt references)
  - **Rules** in `.continue/rules/*.md` (general coding guidelines)

  This example shows how PrompTrek generates Continue's modular file structure.

  ## Generated File Structure

  ```
  .continue/
    config.yaml          # Main configuration with metadata
    mcpServers/          # Individual MCP server YAML files
      filesystem.yaml
      github.yaml
      brave-search.yaml
    prompts/             # Individual slash command markdown files
      refactor.md
      explain.md
      commit.md
    rules/               # General coding rules
      general.md
  ```

  ## Features

  ### MCP Servers (Individual YAML Files)
  Each MCP server gets its own YAML file with Continue's required metadata:
  - `name`: Display name for the server
  - `version`: Server version (0.0.1)
  - `schema`: Configuration schema (v1)
  - `mcpServers`: Array with single server configuration

  ### Slash Commands (Individual Markdown Files)
  Each command is a markdown file with YAML frontmatter:
  - `name`: Command name (used as `/name` in Continue)
  - `description`: What the command does
  - `invokable: true`: Makes it available as a slash command

  ### Config YAML (Main Configuration)
  References all prompt files for automatic loading:
  - `prompts`: Array of `uses: file://...` references
  - `name`, `version`, `schema`: Project metadata

  ## Quick Start

  ```bash
  # Generate Continue modular config
  promptrek plugins generate continue-unified.promptrek.yaml -e continue

  # Restart Continue extension
  # Open VS Code command palette (Cmd/Ctrl+Shift+P)
  # Type "Developer: Reload Window"
  ```

  ## Benefits of Modular Structure

  1. **Better Version Control**: See exactly what changed per server/command
  2. **Easier Sharing**: Share individual MCP servers or commands across projects
  3. **Cleaner Organization**: One file per concern, easier to navigate
  4. **Continue Best Practice**: Follows Continue's official documentation recommendations

plugins:
  mcp_servers:
    # Filesystem server for code access
    - name: filesystem
      command: npx
      args:
        - "-y"
        - "@modelcontextprotocol/server-filesystem"
        - "{{{ WORKSPACE_ROOT }}}"
      description: Access project files
      trust_metadata:
        trusted: true
        trust_level: partial
        requires_approval: true

    # GitHub MCP server
    - name: github
      command: npx
      args:
        - "-y"
        - "@modelcontextprotocol/server-github"
      env:
        GITHUB_TOKEN: "{{{ GITHUB_TOKEN }}}"
      description: GitHub API integration
      trust_metadata:
        trusted: true
        trust_level: full

    # Brave Search for web queries
    - name: brave-search
      command: npx
      args:
        - "-y"
        - "@modelcontextprotocol/server-brave-search"
      env:
        BRAVE_API_KEY: "{{{ BRAVE_API_KEY }}}"
      description: Web search capabilities

  commands:
    # Code refactoring command
    - name: refactor
      description: Refactor selected code for better quality
      prompt: |
        Refactor the selected code following these principles:

        1. **Simplification:**
           - Break down complex functions
           - Reduce nesting levels
           - Extract reusable components

        2. **Naming:**
           - Use descriptive variable names
           - Follow language conventions
           - Avoid abbreviations

        3. **DRY Principle:**
           - Eliminate code duplication
           - Create utility functions
           - Use composition

        4. **Performance:**
           - Optimize loops
           - Reduce allocations
           - Cache when appropriate

        5. **Testing:**
           - Ensure tests still pass
           - Add tests for new functions
           - Maintain coverage

        Show before/after code and explain changes.
      output_format: code
      requires_approval: false
      examples:
        - "/refactor"

    # Explain code command
    - name: explain
      description: Explain how selected code works
      prompt: |
        Provide a clear explanation of this code:

        **Overview:**
        - What does this code do?
        - Why is it structured this way?

        **Details:**
        - Key algorithms and data structures
        - Important variables and their roles
        - Control flow and logic

        **Context:**
        - How it fits in the larger system
        - Dependencies and relationships
        - Potential edge cases

        **Examples:**
        - Input/output examples
        - Common use cases

        Use simple language and include diagrams if helpful.
      output_format: markdown
      requires_approval: false

    # Generate commit message
    - name: commit
      description: Generate a commit message for staged changes
      prompt: |
        Generate a conventional commit message for the staged changes:

        **Format:**
        ```
        <type>(<scope>): <subject>

        <body>

        <footer>
        ```

        **Types:**
        - feat: New feature
        - fix: Bug fix
        - docs: Documentation
        - style: Formatting
        - refactor: Code restructuring
        - test: Adding tests
        - chore: Maintenance

        **Requirements:**
        - Subject max 50 chars
        - Body wraps at 72 chars
        - Explain what and why, not how
        - Reference issue numbers

        Analyze the diff and generate an appropriate message.
      output_format: text
      requires_approval: false
      examples:
        - "/commit"

    # Add type hints (Python/TypeScript)
    - name: types
      description: Add or fix type annotations
      prompt: |
        Add comprehensive type annotations:

        **Python:**
        - Function signatures with typing module
        - Class attributes with type hints
        - Return type annotations
        - Generic types where appropriate

        **TypeScript:**
        - Interface definitions
        - Type aliases
        - Generic constraints
        - Utility types

        **Best Practices:**
        - Use specific types over `any`
        - Define custom types for complex structures
        - Add docstrings/JSDoc
        - Handle optional parameters

        Update the code with proper types.
      output_format: code
      requires_approval: false

    # Performance analysis
    - name: perf
      description: Analyze code performance and suggest optimizations
      prompt: |
        Analyze performance and suggest optimizations:

        **Time Complexity:**
        - Algorithm complexity (Big O)
        - Bottlenecks and slow operations
        - Opportunities for caching

        **Space Complexity:**
        - Memory usage patterns
        - Unnecessary allocations
        - Data structure choices

        **Optimizations:**
        - Algorithm improvements
        - Lazy evaluation
        - Parallel processing
        - Database query optimization

        **Benchmarks:**
        - Expected performance gains
        - Trade-offs to consider

        Provide concrete code examples.
      output_format: markdown
      requires_approval: false

    # Generate tests
    - name: test-gen
      description: Generate comprehensive unit tests
      prompt: |
        Generate unit tests for the selected code:

        **Test Cases:**
        - Happy path (normal inputs)
        - Edge cases (boundary values)
        - Error cases (invalid inputs)
        - Null/undefined handling

        **Structure:**
        - Use Arrange-Act-Assert pattern
        - Clear, descriptive test names
        - One concept per test
        - Mock external dependencies

        **Coverage:**
        - All public methods
        - All branches
        - Error handling paths

        Use the project's testing framework (Jest, pytest, etc.).
      output_format: code
      requires_approval: false
      examples:
        - "/test-gen"

variables:
  WORKSPACE_ROOT: "${workspaceFolder}"
  GITHUB_TOKEN: "ghp_your_github_token"
  BRAVE_API_KEY: "BSA_your_brave_api_key"
