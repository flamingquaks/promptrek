name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write
  packages: write
  id-token: write  # For PyPI trusted publishing

jobs:
  # Build the package once
  build:
    uses: ./.github/workflows/build.yml
    with:
      python-version: '3.12'
      upload-artifacts: true

  # Run comprehensive tests on the build
  test:
    needs: build
    uses: ./.github/workflows/test.yml
    with:
      python-version: '3.12'
      test-suite: 'all'
      coverage: true
      coverage-threshold: 80
      artifact-name: ${{ needs.build.outputs.artifact-name }}

  # Security validation before release
  # security:
  #   needs: build
  #   uses: ./.github/workflows/security.yml
  #   with:
  #     python-version: '3.12'
  #     bandit-severity: 'medium'
  #     fail-on-issues: true  # Strict security for releases

  # Validate package with twine
  validate-package:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Install uv
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true
          python-version: '3.12'
          cache-dependency-glob: "pyproject.toml"

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: dist/

      - name: Install twine
        run: |
          uv add --group dev twine
          uv sync --group dev

      - name: Check package with twine
        run: |
          uv run twine check dist/*
          echo "Package validation successful"

  # Create GitHub release - only for main PyPI releases
  github-release:
    needs: [build, test, validate-package]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') && !contains(github.ref, 'rc') && !contains(github.ref, 'beta') && !contains(github.ref, 'alpha')
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node.js for changelog
        uses: actions/setup-node@v5
        with:
          node-version: 22

      - name: Install conventional-changelog
        run: |
          npm install -g conventional-changelog-cli@5.0.0

      - name: Generate release notes
        run: |
          # Try conventional-changelog with better configuration
          if conventional-changelog -p angular -i RELEASE_NOTES.md -s -r 0 --pkg-path . --tag-prefix v; then
            echo "Successfully generated release notes with conventional-changelog"
          else
            echo "conventional-changelog failed, generating basic release notes"

            # Fallback: Generate basic release notes from git log
            CURRENT_TAG="${{ github.ref_name }}"
            PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "$CURRENT_TAG" | head -n1)

            echo "# Release $CURRENT_TAG" > RELEASE_NOTES.md
            echo "" >> RELEASE_NOTES.md

            if [ -n "$PREVIOUS_TAG" ]; then
              echo "## What's Changed" >> RELEASE_NOTES.md
              echo "" >> RELEASE_NOTES.md
              git log --pretty=format:"- %s" "$PREVIOUS_TAG..$CURRENT_TAG" >> RELEASE_NOTES.md
              echo "" >> RELEASE_NOTES.md
              echo "" >> RELEASE_NOTES.md
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREVIOUS_TAG...$CURRENT_TAG" >> RELEASE_NOTES.md
            else
              echo "## Initial Release" >> RELEASE_NOTES.md
              echo "" >> RELEASE_NOTES.md
              echo "This is the initial release of the project." >> RELEASE_NOTES.md
            fi
          fi

          # Show what was generated
          echo "Generated release notes:"
          cat RELEASE_NOTES.md

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: dist/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to PyPI (using the same artifacts) - only for non-RC releases
  publish-pypi:
    needs: [build, test, validate-package, github-release]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') && !contains(github.ref, 'rc') && !contains(github.ref, 'beta') && !contains(github.ref, 'alpha')
    environment:
      name: pypi
      url: https://pypi.org/project/promptrek/

    permissions:
      id-token: write

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          print-hash: true
          verify-metadata: true

  # Publish to Test PyPI for RC, beta, and alpha releases
  publish-test-pypi:
    needs: [build, test, validate-package]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') && (contains(github.ref, 'rc') || contains(github.ref, 'beta') || contains(github.ref, 'alpha'))
    environment:
      name: testpypi
      url: https://test.pypi.org/project/promptrek/

    permissions:
      id-token: write

    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install twine and requests
        run: |
          pip install twine requests

      - name: Extract version info
        id: version
        run: |
          # Extract base version from tag (e.g., v0.0.0-rc.1 -> 0.0.0)
          TAG="${{ github.ref_name }}"
          BASE_VERSION=$(echo "$TAG" | sed 's/^v//' | sed 's/-.*$//')
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "Base version: $BASE_VERSION"

      - name: Yank previous RCs from Test PyPI
        continue-on-error: true  # Don't fail if yanking fails
        env:
          TEST_PYPI_TOKEN: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          BASE_VERSION="${{ steps.version.outputs.base_version }}"
          echo "Looking for previous RCs of version $BASE_VERSION"

          # Create Python script to find and yank old RCs
          cat > yank_old_rcs.py << 'EOF'
          import json
          import os
          import sys
          import requests

          base_version = sys.argv[1]
          current_tag = sys.argv[2].replace('v', '')
          token = os.environ.get('TEST_PYPI_TOKEN')

          if not token:
              print("Warning: TEST_PYPI_API_TOKEN not set, skipping yanking")
              sys.exit(0)

          # Get package info from Test PyPI
          response = requests.get('https://test.pypi.org/pypi/promptrek/json')
          if response.status_code == 404:
              print("Package not found on Test PyPI yet")
              sys.exit(0)

          data = response.json()
          releases = data.get('releases', {})

          # Find all RC versions for this base version (including current if it exists)
          yanked_versions = []
          for version in releases.keys():
              # Check if this is an RC of our base version
              if version.startswith(f"{base_version}-rc."):
                  if version == current_tag:
                      print(f"Found current RC already on Test PyPI, will yank and re-upload: {version}")
                  else:
                      print(f"Found old RC to yank: {version}")

                  # Yank via PyPI API
                  headers = {
                      'Authorization': f'Bearer {token}',
                      'Content-Type': 'application/json'
                  }

                  # PyPI yanking is done via DELETE request
                  for file_info in releases[version]:
                      filename = file_info['filename']
                      yank_url = f'https://test.pypi.org/legacy/promptrek/{version}/{filename}'

                      try:
                          resp = requests.delete(yank_url, headers=headers)
                          if resp.status_code in [200, 204]:
                              print(f"  Yanked: {filename}")
                          else:
                              print(f"  Warning: Could not yank {filename}: {resp.status_code}")
                      except Exception as e:
                          print(f"  Warning: Error yanking {filename}: {e}")

                  yanked_versions.append(version)

          if yanked_versions:
              print(f"Yanked {len(yanked_versions)} old RC version(s): {', '.join(yanked_versions)}")
          else:
              print("No old RC versions found to yank")
          EOF

          python yank_old_rcs.py "$BASE_VERSION" "${{ github.ref_name }}" || true

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: dist/

      - name: Publish to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          print-hash: true
          verify-metadata: true
          skip-existing: true  # Skip if version already exists

  # Final success check
  release-success:
    needs: [build, test, validate-package]
    runs-on: ubuntu-latest
    if: always() && startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Check Release Status
        run: |
          echo "## Release Summary"

          # Check based on what type of release this is
          if [[ "${{ github.ref }}" == *"rc"* ]] || [[ "${{ github.ref }}" == *"beta"* ]] || [[ "${{ github.ref }}" == *"alpha"* ]]; then
            # For pre-releases, only Test PyPI should run
            echo "Pre-release to Test PyPI"
            echo "Build: ${{ needs.build.result }}"
            echo "Test: ${{ needs.test.result }}"
            echo "Validate: ${{ needs.validate-package.result }}"

            if [ "${{ needs.build.result }}" != "success" ] || \
               [ "${{ needs.test.result }}" != "success" ] || \
               [ "${{ needs.validate-package.result }}" != "success" ]; then
              echo "Pre-release preparation failed"
              exit 1
            fi
            echo "Pre-release to Test PyPI ready! 🚀"
          else
            # For regular releases, check all components
            echo "Full release to PyPI"
            echo "Build: ${{ needs.build.result }}"
            echo "Test: ${{ needs.test.result }}"
            echo "Validate: ${{ needs.validate-package.result }}"

            if [ "${{ needs.build.result }}" != "success" ] || \
               [ "${{ needs.test.result }}" != "success" ] || \
               [ "${{ needs.validate-package.result }}" != "success" ]; then
              echo "Release preparation failed"
              exit 1
            fi
            echo "Release to PyPI ready! 🎉"
          fi
