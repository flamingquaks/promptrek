"""
Spec management utilities for Universal Spec Format (USF).

Handles operations on promptrek/specs.yaml registry and individual spec files.

NOTE: Uses 'promptrek/' (without dot) for COMMITTED spec files that are shared
with the team. The '.promptrek/' directory (with dot) is gitignored and used
only for user-specific files like variables and user-config.
"""

import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Optional

import yaml

from promptrek.core.exceptions import (
    SpecFileError,
    SpecNotFoundError,
    SpecRegistryError,
)
from promptrek.core.models import SpecMetadata, UniversalSpecFormat


class SpecManager:
    """
    Manages spec-driven project documents.

    Handles the USF registry (promptrek/specs.yaml) and individual spec files
    stored in promptrek/specs/ directory (COMMITTED, not gitignored).
    """

    def __init__(self, project_root: Path):
        """
        Initialize the spec manager.

        Args:
            project_root: Root directory of the project
        """
        self.project_root = Path(project_root)
        self.specs_dir = self.project_root / "promptrek" / "specs"
        self.registry_path = self.project_root / "promptrek" / "specs.yaml"

    def ensure_specs_directory(self) -> None:
        """Create promptrek/specs/ directory if it doesn't exist."""
        self.specs_dir.mkdir(parents=True, exist_ok=True)

    def load_registry(self) -> UniversalSpecFormat:
        """
        Load the USF registry from promptrek/specs.yaml.

        Returns:
            UniversalSpecFormat: The loaded registry or empty one if file doesn't exist

        Raises:
            SpecRegistryError: If the registry file is malformed or cannot be read
        """
        if not self.registry_path.exists():
            return UniversalSpecFormat(schema_version="1.0.0", specs=[])

        try:
            with open(self.registry_path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if not data:
                    return UniversalSpecFormat(schema_version="1.0.0", specs=[])
                return UniversalSpecFormat(**data)
        except yaml.YAMLError as e:
            raise SpecRegistryError(
                f"Failed to parse specs.yaml: {e}. "
                f"The registry file may be corrupted. "
                f"Check {self.registry_path} for YAML syntax errors."
            ) from e
        except PermissionError as e:
            raise SpecRegistryError(
                f"Permission denied reading {self.registry_path}. "
                f"Please check file permissions."
            ) from e
        except UnicodeDecodeError as e:
            raise SpecRegistryError(
                f"Failed to decode {self.registry_path} (encoding issue). "
                f"Ensure the file is UTF-8 encoded."
            ) from e
        except Exception as e:
            raise SpecRegistryError(
                f"Unexpected error loading registry from {self.registry_path}: {e}"
            ) from e

    def save_registry(self, usf: UniversalSpecFormat) -> None:
        """
        Save the USF registry to promptrek/specs.yaml.

        Args:
            usf: The UniversalSpecFormat to save

        Raises:
            SpecRegistryError: If the registry cannot be written
        """
        try:
            self.ensure_specs_directory()
            data = usf.model_dump(exclude_none=True)

            with open(self.registry_path, "w", encoding="utf-8") as f:
                # Add schema reference comment
                f.write("# Universal Spec Format (USF) Registry\n")
                f.write("# This file tracks all spec-driven project documents\n")
                f.write("# This file is COMMITTED - shared with your team\n")
                f.write("# Generated by promptrek - do not edit manually\n\n")
                yaml.dump(
                    data,
                    f,
                    default_flow_style=False,
                    sort_keys=False,
                    allow_unicode=True,
                )
        except PermissionError as e:
            raise SpecRegistryError(
                f"Permission denied writing to {self.registry_path}. "
                f"Please check directory permissions."
            ) from e
        except OSError as e:
            raise SpecRegistryError(
                f"Failed to write registry to {self.registry_path}: {e}. "
                f"Check available disk space and filesystem health."
            ) from e
        except Exception as e:
            raise SpecRegistryError(
                f"Unexpected error saving registry to {self.registry_path}: {e}"
            ) from e

    def _write_spec_file(
        self, file_path: Path, metadata: SpecMetadata, content: str
    ) -> None:
        """
        Write a spec file with metadata header.

        Args:
            file_path: Path to write the spec file
            metadata: Spec metadata to include in header
            content: Markdown content to write after header
        """
        with open(file_path, "w", encoding="utf-8") as f:
            # Write USF documentation comments at the top
            f.write(
                "<!-- yaml-language-server: $schema=https://promptrek.com/schema/spec/v1.0.0.json -->\n"
            )
            f.write("<!-- Universal Spec Format (USF) - PrompTrek Spec Document -->\n")
            f.write("<!-- This is a specification document managed by PrompTrek -->\n")
            f.write(
                "<!-- Learn more about specs: https://docs.promptrek.com/concepts/specs -->\n\n"
            )

            # Write title and metadata
            f.write(f"# {metadata.title}\n\n")
            f.write(f"**ID:** {metadata.id}  \n")
            f.write(f"**Created:** {metadata.created}  \n")
            if metadata.updated:
                f.write(f"**Updated:** {metadata.updated}  \n")
            f.write(f"**Source:** {metadata.source_command}  \n")
            if metadata.summary:
                f.write(f"**Summary:** {metadata.summary}  \n")
            if metadata.tags:
                f.write(f"**Tags:** {', '.join(metadata.tags)}  \n")
            f.write("\n---\n\n")
            f.write(content)

    def create_spec(
        self,
        title: str,
        content: str,
        source_command: str,
        summary: Optional[str] = None,
        tags: Optional[List[str]] = None,
    ) -> SpecMetadata:
        """
        Create a new spec file and register it in the USF.

        Args:
            title: Human-readable title for the spec
            content: Markdown content of the spec
            source_command: Command that created this spec
            summary: Optional brief summary
            tags: Optional tags for categorization

        Returns:
            SpecMetadata: Metadata for the created spec
        """
        spec_id = str(uuid.uuid4())[:8]
        filename = self._generate_filename(title, spec_id)
        now = datetime.now().isoformat()

        metadata = SpecMetadata(
            id=spec_id,
            title=title,
            path=filename,
            source_command=source_command,
            created=now,
            summary=summary,
            tags=tags,
        )

        self.ensure_specs_directory()
        spec_file_path = self.specs_dir / filename
        self._write_spec_file(spec_file_path, metadata, content)

        usf = self.load_registry()
        usf.specs.append(metadata)
        self.save_registry(usf)

        return metadata

    def update_spec(
        self,
        spec_id: str,
        content: Optional[str] = None,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        tags: Optional[List[str]] = None,
    ) -> SpecMetadata:
        """
        Update an existing spec.

        Args:
            spec_id: ID of the spec to update
            content: New content (if provided)
            title: New title (if provided)
            summary: New summary (if provided)
            tags: New tags (if provided)

        Returns:
            SpecMetadata: Updated metadata

        Raises:
            SpecNotFoundError: If spec not found in registry
        """
        usf = self.load_registry()

        spec = next((s for s in usf.specs if s.id == spec_id), None)
        if not spec:
            available_specs = [f"'{s.id}' ({s.title})" for s in usf.specs[:5]]
            spec_list = ", ".join(available_specs) if available_specs else "none"
            more_msg = f" and {len(usf.specs) - 5} more" if len(usf.specs) > 5 else ""
            raise SpecNotFoundError(
                f"Spec with ID '{spec_id}' not found in registry. "
                f"Available specs: {spec_list}{more_msg}. "
                f"Run 'promptrek list-specs' to see all specs."
            )

        spec.updated = datetime.now().isoformat()

        if title:
            spec.title = title
        if summary:
            spec.summary = summary
        if tags is not None:
            spec.tags = tags

        if content:
            spec_file_path = self.specs_dir / spec.path
            self._write_spec_file(spec_file_path, spec, content)

        self.save_registry(usf)

        return spec

    def get_spec_by_id(self, spec_id: str) -> Optional[SpecMetadata]:
        """
        Get spec metadata by ID.

        Args:
            spec_id: ID of the spec

        Returns:
            SpecMetadata if found, None otherwise
        """
        usf = self.load_registry()
        for spec in usf.specs:
            if spec.id == spec_id:
                return spec
        return None

    def list_specs(self) -> List[SpecMetadata]:
        """
        List all registered specs.

        Returns:
            List of SpecMetadata objects
        """
        usf = self.load_registry()
        return usf.specs

    def get_spec_content(self, spec_id: str) -> str:
        """
        Get the content of a spec file.

        Args:
            spec_id: ID of the spec

        Returns:
            Content of the spec file

        Raises:
            SpecNotFoundError: If spec not found in registry
            SpecFileError: If spec file doesn't exist or cannot be read
        """
        spec = self.get_spec_by_id(spec_id)
        if not spec:
            raise SpecNotFoundError(
                f"Spec with ID '{spec_id}' not found in registry. "
                f"Run 'promptrek list-specs' to see available specs."
            )

        spec_file_path = self.specs_dir / spec.path
        if not spec_file_path.exists():
            raise SpecFileError(
                f"Spec file not found at {spec_file_path}. "
                f"The registry references this file but it doesn't exist on disk. "
                f"This usually means the registry is out of sync. "
                f"Try running 'promptrek list-specs' to verify."
            )

        try:
            with open(spec_file_path, "r", encoding="utf-8") as f:
                return f.read()
        except PermissionError as e:
            raise SpecFileError(
                f"Permission denied reading spec file {spec_file_path}. "
                f"Please check file permissions."
            ) from e
        except UnicodeDecodeError as e:
            raise SpecFileError(
                f"Failed to decode spec file {spec_file_path} (encoding issue). "
                f"Ensure file is UTF-8 encoded."
            ) from e
        except Exception as e:
            raise SpecFileError(
                f"Unexpected error reading spec file {spec_file_path}: {e}"
            ) from e

    def export_spec(self, spec_id: str, output_path: Path, clean: bool = True) -> None:
        """
        Export a spec to a markdown file.

        Args:
            spec_id: ID of the spec to export
            output_path: Path to export the spec to
            clean: If True, remove metadata header from export

        Raises:
            ValueError: If spec not found
        """
        content = self.get_spec_content(spec_id)

        if clean:
            # Remove metadata header (everything before the --- separator)
            parts = content.split("\n---\n", 1)
            if len(parts) > 1:
                content = parts[1].strip()

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

    def sync_specs_from_disk(self) -> List[SpecMetadata]:
        """
        Detect new spec files in promptrek/specs/ and register them.

        Scans the specs directory for markdown files not in the registry
        and adds them with basic metadata.

        Returns:
            List of newly registered specs
        """
        if not self.specs_dir.exists():
            return []

        usf = self.load_registry()
        registered_paths = {spec.path for spec in usf.specs}

        new_specs = []
        for spec_file in self.specs_dir.glob("*.md"):
            relative_path = spec_file.name

            if relative_path not in registered_paths:
                # Parse metadata from file if present
                with open(spec_file, "r", encoding="utf-8") as f:
                    content = f.read()

                title = self._extract_title_from_content(content)
                spec_id = str(uuid.uuid4())[:8]
                now = datetime.now().isoformat()

                metadata = SpecMetadata(
                    id=spec_id,
                    title=title,
                    path=relative_path,
                    source_command="sync",
                    created=now,
                    summary="Synced from disk",
                )

                usf.specs.append(metadata)
                new_specs.append(metadata)

        if new_specs:
            self.save_registry(usf)

        return new_specs

    def _generate_filename(self, title: str, spec_id: str) -> str:
        """
        Generate a filename from the title (AI-driven naming simulation).

        Args:
            title: The spec title
            spec_id: Unique ID for the spec

        Returns:
            Filename with .md extension
        """
        # Simple slug generation from title
        slug = title.lower()
        slug = "".join(c if c.isalnum() or c.isspace() else "" for c in slug)
        slug = "-".join(slug.split())
        slug = slug[:50]  # Limit length

        return f"{slug}-{spec_id}.md"

    def _extract_title_from_content(self, content: str) -> str:
        """
        Extract title from spec content.

        Args:
            content: Spec file content

        Returns:
            Extracted title or default
        """
        lines = content.split("\n")
        for line in lines:
            if line.startswith("# "):
                return line[2:].strip()
        return "Untitled Spec"

    @property
    def _constitution_path(self) -> Path:
        """
        Get the path to the constitution file.

        Returns:
            Path to constitution.md in promptrek directory
        """
        return self.project_root / "promptrek" / "constitution.md"

    def create_or_update_constitution(self, content: str) -> Path:
        """
        Create or completely replace project constitution.

        The constitution is a special document (not tracked in specs.yaml registry)
        that contains project-wide values, anti-patterns, and working agreements.

        Note: This method completely replaces the existing constitution file if it exists.
        It does not merge or append to existing content.

        Args:
            content: Markdown content for constitution

        Returns:
            Path to constitution file (promptrek/constitution.md)
        """
        self._constitution_path.parent.mkdir(parents=True, exist_ok=True)
        self._constitution_path.write_text(content, encoding="utf-8")
        return self._constitution_path

    def get_constitution_content(self) -> Optional[str]:
        """
        Get constitution content if it exists.

        Returns:
            Constitution markdown content, or None if file doesn't exist
        """
        if self._constitution_path.exists():
            return self._constitution_path.read_text(encoding="utf-8")
        return None

    def constitution_exists(self) -> bool:
        """
        Check if constitution file exists.

        Returns:
            True if constitution.md exists, False otherwise
        """
        return self._constitution_path.exists()
