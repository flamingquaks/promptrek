"""
Spec management utilities for Universal Spec Format (USF).

Handles operations on promptrek/specs.yaml registry and individual spec files.

NOTE: Uses 'promptrek/' (without dot) for COMMITTED spec files that are shared
with the team. The '.promptrek/' directory (with dot) is gitignored and used
only for user-specific files like variables and user-config.
"""

import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Optional

import yaml

from promptrek.core.models import SpecMetadata, UniversalSpecFormat


class SpecManager:
    """
    Manages spec-driven project documents.

    Handles the USF registry (promptrek/specs.yaml) and individual spec files
    stored in promptrek/specs/ directory (COMMITTED, not gitignored).
    """

    def __init__(self, project_root: Path):
        """
        Initialize the spec manager.

        Args:
            project_root: Root directory of the project
        """
        self.project_root = Path(project_root)
        self.specs_dir = self.project_root / "promptrek" / "specs"
        self.registry_path = self.project_root / "promptrek" / "specs.yaml"

    def ensure_specs_directory(self) -> None:
        """Create promptrek/specs/ directory if it doesn't exist."""
        self.specs_dir.mkdir(parents=True, exist_ok=True)

    def load_registry(self) -> UniversalSpecFormat:
        """
        Load the USF registry from promptrek/specs.yaml.

        Returns:
            UniversalSpecFormat: The loaded registry or empty one if file doesn't exist

        Raises:
            ValueError: If the registry file is malformed
        """
        if not self.registry_path.exists():
            return UniversalSpecFormat(schema_version="1.0.0", specs=[])

        try:
            with open(self.registry_path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                if not data:
                    return UniversalSpecFormat(schema_version="1.0.0", specs=[])
                return UniversalSpecFormat(**data)
        except yaml.YAMLError as e:
            raise ValueError(f"Failed to parse specs.yaml: {e}")
        except Exception as e:
            raise ValueError(f"Failed to load specs.yaml: {e}")

    def save_registry(self, usf: UniversalSpecFormat) -> None:
        """
        Save the USF registry to promptrek/specs.yaml.

        Args:
            usf: The UniversalSpecFormat to save
        """
        self.ensure_specs_directory()

        data = usf.model_dump(exclude_none=True)

        with open(self.registry_path, "w", encoding="utf-8") as f:
            # Add schema reference comment
            f.write("# Universal Spec Format (USF) Registry\n")
            f.write("# This file tracks all spec-driven project documents\n")
            f.write("# This file is COMMITTED - shared with your team\n")
            f.write("# Generated by promptrek - do not edit manually\n\n")
            yaml.dump(
                data, f, default_flow_style=False, sort_keys=False, allow_unicode=True
            )

    def create_spec(
        self,
        title: str,
        content: str,
        source_command: str,
        summary: Optional[str] = None,
        tags: Optional[List[str]] = None,
    ) -> SpecMetadata:
        """
        Create a new spec file and register it in the USF.

        Args:
            title: Human-readable title for the spec
            content: Markdown content of the spec
            source_command: Command that created this spec
            summary: Optional brief summary
            tags: Optional tags for categorization

        Returns:
            SpecMetadata: Metadata for the created spec
        """
        # Generate unique ID
        spec_id = str(uuid.uuid4())[:8]

        # Generate filename from title (AI-driven naming simulation)
        filename = self._generate_filename(title, spec_id)
        relative_path = f"{filename}"

        # Create spec metadata
        now = datetime.now().isoformat()
        metadata = SpecMetadata(
            id=spec_id,
            title=title,
            path=relative_path,
            source_command=source_command,
            created=now,
            summary=summary,
            tags=tags,
        )

        # Write spec content to file
        spec_file_path = self.specs_dir / filename
        self.ensure_specs_directory()

        with open(spec_file_path, "w", encoding="utf-8") as f:
            f.write(f"# {title}\n\n")
            f.write(f"**ID:** {spec_id}  \n")
            f.write(f"**Created:** {now}  \n")
            f.write(f"**Source:** {source_command}  \n")
            if summary:
                f.write(f"**Summary:** {summary}  \n")
            if tags:
                f.write(f"**Tags:** {', '.join(tags)}  \n")
            f.write("\n---\n\n")
            f.write(content)

        # Add to registry
        usf = self.load_registry()
        usf.specs.append(metadata)
        self.save_registry(usf)

        return metadata

    def update_spec(
        self,
        spec_id: str,
        content: Optional[str] = None,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        tags: Optional[List[str]] = None,
    ) -> SpecMetadata:
        """
        Update an existing spec.

        Args:
            spec_id: ID of the spec to update
            content: New content (if provided)
            title: New title (if provided)
            summary: New summary (if provided)
            tags: New tags (if provided)

        Returns:
            SpecMetadata: Updated metadata

        Raises:
            ValueError: If spec not found
        """
        usf = self.load_registry()

        # Find spec in the loaded registry
        spec = None
        for s in usf.specs:
            if s.id == spec_id:
                spec = s
                break

        if not spec:
            raise ValueError(f"Spec with ID {spec_id} not found")

        # Update metadata
        now = datetime.now().isoformat()
        spec.updated = now

        if title:
            spec.title = title
        if summary:
            spec.summary = summary
        if tags is not None:
            spec.tags = tags

        # Update content if provided
        if content:
            spec_file_path = self.specs_dir / spec.path
            with open(spec_file_path, "w", encoding="utf-8") as f:
                f.write(f"# {spec.title}\n\n")
                f.write(f"**ID:** {spec.id}  \n")
                f.write(f"**Created:** {spec.created}  \n")
                f.write(f"**Updated:** {now}  \n")
                f.write(f"**Source:** {spec.source_command}  \n")
                if spec.summary:
                    f.write(f"**Summary:** {spec.summary}  \n")
                if spec.tags:
                    f.write(f"**Tags:** {', '.join(spec.tags)}  \n")
                f.write("\n---\n\n")
                f.write(content)

        # Save updated registry
        self.save_registry(usf)

        return spec

    def get_spec_by_id(self, spec_id: str) -> Optional[SpecMetadata]:
        """
        Get spec metadata by ID.

        Args:
            spec_id: ID of the spec

        Returns:
            SpecMetadata if found, None otherwise
        """
        usf = self.load_registry()
        for spec in usf.specs:
            if spec.id == spec_id:
                return spec
        return None

    def list_specs(self) -> List[SpecMetadata]:
        """
        List all registered specs.

        Returns:
            List of SpecMetadata objects
        """
        usf = self.load_registry()
        return usf.specs

    def get_spec_content(self, spec_id: str) -> str:
        """
        Get the content of a spec file.

        Args:
            spec_id: ID of the spec

        Returns:
            Content of the spec file

        Raises:
            ValueError: If spec not found
            FileNotFoundError: If spec file doesn't exist
        """
        spec = self.get_spec_by_id(spec_id)
        if not spec:
            raise ValueError(f"Spec with ID {spec_id} not found")

        spec_file_path = self.specs_dir / spec.path
        if not spec_file_path.exists():
            raise FileNotFoundError(f"Spec file not found: {spec.path}")

        with open(spec_file_path, "r", encoding="utf-8") as f:
            return f.read()

    def export_spec(self, spec_id: str, output_path: Path, clean: bool = True) -> None:
        """
        Export a spec to a markdown file.

        Args:
            spec_id: ID of the spec to export
            output_path: Path to export the spec to
            clean: If True, remove metadata header from export

        Raises:
            ValueError: If spec not found
        """
        content = self.get_spec_content(spec_id)

        if clean:
            # Remove metadata header (everything before the --- separator)
            parts = content.split("\n---\n", 1)
            if len(parts) > 1:
                content = parts[1].strip()

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

    def sync_specs_from_disk(self) -> List[SpecMetadata]:
        """
        Detect new spec files in .promptrek/specs/ and register them.

        Scans the specs directory for markdown files not in the registry
        and adds them with basic metadata.

        Returns:
            List of newly registered specs
        """
        if not self.specs_dir.exists():
            return []

        usf = self.load_registry()
        registered_paths = {spec.path for spec in usf.specs}

        new_specs = []
        for spec_file in self.specs_dir.glob("*.md"):
            relative_path = spec_file.name

            if relative_path not in registered_paths:
                # Parse metadata from file if present
                with open(spec_file, "r", encoding="utf-8") as f:
                    content = f.read()

                title = self._extract_title_from_content(content)
                spec_id = str(uuid.uuid4())[:8]
                now = datetime.now().isoformat()

                metadata = SpecMetadata(
                    id=spec_id,
                    title=title,
                    path=relative_path,
                    source_command="sync",
                    created=now,
                    summary="Synced from disk",
                )

                usf.specs.append(metadata)
                new_specs.append(metadata)

        if new_specs:
            self.save_registry(usf)

        return new_specs

    def _generate_filename(self, title: str, spec_id: str) -> str:
        """
        Generate a filename from the title (AI-driven naming simulation).

        Args:
            title: The spec title
            spec_id: Unique ID for the spec

        Returns:
            Filename with .md extension
        """
        # Simple slug generation from title
        slug = title.lower()
        slug = "".join(c if c.isalnum() or c.isspace() else "" for c in slug)
        slug = "-".join(slug.split())
        slug = slug[:50]  # Limit length

        return f"{slug}-{spec_id}.md"

    def _extract_title_from_content(self, content: str) -> str:
        """
        Extract title from spec content.

        Args:
            content: Spec file content

        Returns:
            Extracted title or default
        """
        lines = content.split("\n")
        for line in lines:
            if line.startswith("# "):
                return line[2:].strip()
        return "Untitled Spec"
